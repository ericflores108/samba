/*
Spotify Web API

You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spotify

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type PlayerAPI interface {

	/*
	AddToQueue Add Item to Playback Queue 

	Add an item to be played next in the user's current playback queue. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIAddToQueueRequest
	*/
	AddToQueue(ctx context.Context) PlayerAPIAddToQueueRequest

	// AddToQueueExecute executes the request
	AddToQueueExecute(r PlayerAPIAddToQueueRequest) (*http.Response, error)

	/*
	GetAUsersAvailableDevices Get Available Devices 

	Get information about a user’s available Spotify Connect devices. Some device models are not supported and will not be listed in the API response.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIGetAUsersAvailableDevicesRequest
	*/
	GetAUsersAvailableDevices(ctx context.Context) PlayerAPIGetAUsersAvailableDevicesRequest

	// GetAUsersAvailableDevicesExecute executes the request
	//  @return GetAUsersAvailableDevices200Response
	GetAUsersAvailableDevicesExecute(r PlayerAPIGetAUsersAvailableDevicesRequest) (*GetAUsersAvailableDevices200Response, *http.Response, error)

	/*
	GetInformationAboutTheUsersCurrentPlayback Get Playback State 

	Get information about the user’s current playback state, including track or episode, progress, and active device.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest
	*/
	GetInformationAboutTheUsersCurrentPlayback(ctx context.Context) PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest

	// GetInformationAboutTheUsersCurrentPlaybackExecute executes the request
	//  @return CurrentlyPlayingContextObject
	GetInformationAboutTheUsersCurrentPlaybackExecute(r PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest) (*CurrentlyPlayingContextObject, *http.Response, error)

	/*
	GetQueue Get the User's Queue 

	Get the list of objects that make up the user's queue.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIGetQueueRequest
	*/
	GetQueue(ctx context.Context) PlayerAPIGetQueueRequest

	// GetQueueExecute executes the request
	//  @return QueueObject
	GetQueueExecute(r PlayerAPIGetQueueRequest) (*QueueObject, *http.Response, error)

	/*
	GetRecentlyPlayed Get Recently Played Tracks 

	Get tracks from the current user's recently played tracks.
_**Note**: Currently doesn't support podcast episodes._


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIGetRecentlyPlayedRequest
	*/
	GetRecentlyPlayed(ctx context.Context) PlayerAPIGetRecentlyPlayedRequest

	// GetRecentlyPlayedExecute executes the request
	//  @return CursorPagingPlayHistoryObject
	GetRecentlyPlayedExecute(r PlayerAPIGetRecentlyPlayedRequest) (*CursorPagingPlayHistoryObject, *http.Response, error)

	/*
	GetTheUsersCurrentlyPlayingTrack Get Currently Playing Track 

	Get the object currently being played on the user's Spotify account.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest
	*/
	GetTheUsersCurrentlyPlayingTrack(ctx context.Context) PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest

	// GetTheUsersCurrentlyPlayingTrackExecute executes the request
	//  @return CurrentlyPlayingContextObject
	GetTheUsersCurrentlyPlayingTrackExecute(r PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest) (*CurrentlyPlayingContextObject, *http.Response, error)

	/*
	PauseAUsersPlayback Pause Playback 

	Pause playback on the user's account. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIPauseAUsersPlaybackRequest
	*/
	PauseAUsersPlayback(ctx context.Context) PlayerAPIPauseAUsersPlaybackRequest

	// PauseAUsersPlaybackExecute executes the request
	PauseAUsersPlaybackExecute(r PlayerAPIPauseAUsersPlaybackRequest) (*http.Response, error)

	/*
	SeekToPositionInCurrentlyPlayingTrack Seek To Position 

	Seeks to the given position in the user’s currently playing track. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest
	*/
	SeekToPositionInCurrentlyPlayingTrack(ctx context.Context) PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest

	// SeekToPositionInCurrentlyPlayingTrackExecute executes the request
	SeekToPositionInCurrentlyPlayingTrackExecute(r PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest) (*http.Response, error)

	/*
	SetRepeatModeOnUsersPlayback Set Repeat Mode 

	Set the repeat mode for the user's playback. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPISetRepeatModeOnUsersPlaybackRequest
	*/
	SetRepeatModeOnUsersPlayback(ctx context.Context) PlayerAPISetRepeatModeOnUsersPlaybackRequest

	// SetRepeatModeOnUsersPlaybackExecute executes the request
	SetRepeatModeOnUsersPlaybackExecute(r PlayerAPISetRepeatModeOnUsersPlaybackRequest) (*http.Response, error)

	/*
	SetVolumeForUsersPlayback Set Playback Volume 

	Set the volume for the user’s current playback device. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPISetVolumeForUsersPlaybackRequest
	*/
	SetVolumeForUsersPlayback(ctx context.Context) PlayerAPISetVolumeForUsersPlaybackRequest

	// SetVolumeForUsersPlaybackExecute executes the request
	SetVolumeForUsersPlaybackExecute(r PlayerAPISetVolumeForUsersPlaybackRequest) (*http.Response, error)

	/*
	SkipUsersPlaybackToNextTrack Skip To Next 

	Skips to next track in the user’s queue. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPISkipUsersPlaybackToNextTrackRequest
	*/
	SkipUsersPlaybackToNextTrack(ctx context.Context) PlayerAPISkipUsersPlaybackToNextTrackRequest

	// SkipUsersPlaybackToNextTrackExecute executes the request
	SkipUsersPlaybackToNextTrackExecute(r PlayerAPISkipUsersPlaybackToNextTrackRequest) (*http.Response, error)

	/*
	SkipUsersPlaybackToPreviousTrack Skip To Previous 

	Skips to previous track in the user’s queue. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPISkipUsersPlaybackToPreviousTrackRequest
	*/
	SkipUsersPlaybackToPreviousTrack(ctx context.Context) PlayerAPISkipUsersPlaybackToPreviousTrackRequest

	// SkipUsersPlaybackToPreviousTrackExecute executes the request
	SkipUsersPlaybackToPreviousTrackExecute(r PlayerAPISkipUsersPlaybackToPreviousTrackRequest) (*http.Response, error)

	/*
	StartAUsersPlayback Start/Resume Playback 

	Start a new context or resume current playback on the user's active device. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIStartAUsersPlaybackRequest
	*/
	StartAUsersPlayback(ctx context.Context) PlayerAPIStartAUsersPlaybackRequest

	// StartAUsersPlaybackExecute executes the request
	StartAUsersPlaybackExecute(r PlayerAPIStartAUsersPlaybackRequest) (*http.Response, error)

	/*
	ToggleShuffleForUsersPlayback Toggle Playback Shuffle 

	Toggle shuffle on or off for user’s playback. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPIToggleShuffleForUsersPlaybackRequest
	*/
	ToggleShuffleForUsersPlayback(ctx context.Context) PlayerAPIToggleShuffleForUsersPlaybackRequest

	// ToggleShuffleForUsersPlaybackExecute executes the request
	ToggleShuffleForUsersPlaybackExecute(r PlayerAPIToggleShuffleForUsersPlaybackRequest) (*http.Response, error)

	/*
	TransferAUsersPlayback Transfer Playback 

	Transfer playback to a new device and optionally begin playback. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PlayerAPITransferAUsersPlaybackRequest
	*/
	TransferAUsersPlayback(ctx context.Context) PlayerAPITransferAUsersPlaybackRequest

	// TransferAUsersPlaybackExecute executes the request
	TransferAUsersPlaybackExecute(r PlayerAPITransferAUsersPlaybackRequest) (*http.Response, error)
}

// PlayerAPIService PlayerAPI service
type PlayerAPIService service

type PlayerAPIAddToQueueRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	uri *string
	deviceId *string
}

func (r PlayerAPIAddToQueueRequest) Uri(uri string) PlayerAPIAddToQueueRequest {
	r.uri = &uri
	return r
}

func (r PlayerAPIAddToQueueRequest) DeviceId(deviceId string) PlayerAPIAddToQueueRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPIAddToQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddToQueueExecute(r)
}

/*
AddToQueue Add Item to Playback Queue 

Add an item to be played next in the user's current playback queue. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIAddToQueueRequest
*/
func (a *PlayerAPIService) AddToQueue(ctx context.Context) PlayerAPIAddToQueueRequest {
	return PlayerAPIAddToQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) AddToQueueExecute(r PlayerAPIAddToQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.AddToQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/queue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uri == nil {
		return nil, reportError("uri is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uri", r.uri, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPIGetAUsersAvailableDevicesRequest struct {
	ctx context.Context
	ApiService PlayerAPI
}

func (r PlayerAPIGetAUsersAvailableDevicesRequest) Execute() (*GetAUsersAvailableDevices200Response, *http.Response, error) {
	return r.ApiService.GetAUsersAvailableDevicesExecute(r)
}

/*
GetAUsersAvailableDevices Get Available Devices 

Get information about a user’s available Spotify Connect devices. Some device models are not supported and will not be listed in the API response.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIGetAUsersAvailableDevicesRequest
*/
func (a *PlayerAPIService) GetAUsersAvailableDevices(ctx context.Context) PlayerAPIGetAUsersAvailableDevicesRequest {
	return PlayerAPIGetAUsersAvailableDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAUsersAvailableDevices200Response
func (a *PlayerAPIService) GetAUsersAvailableDevicesExecute(r PlayerAPIGetAUsersAvailableDevicesRequest) (*GetAUsersAvailableDevices200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAUsersAvailableDevices200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.GetAUsersAvailableDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	market *string
	additionalTypes *string
}

func (r PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest) Market(market string) PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest {
	r.market = &market
	return r
}

func (r PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest) AdditionalTypes(additionalTypes string) PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest {
	r.additionalTypes = &additionalTypes
	return r
}

func (r PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest) Execute() (*CurrentlyPlayingContextObject, *http.Response, error) {
	return r.ApiService.GetInformationAboutTheUsersCurrentPlaybackExecute(r)
}

/*
GetInformationAboutTheUsersCurrentPlayback Get Playback State 

Get information about the user’s current playback state, including track or episode, progress, and active device.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest
*/
func (a *PlayerAPIService) GetInformationAboutTheUsersCurrentPlayback(ctx context.Context) PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest {
	return PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrentlyPlayingContextObject
func (a *PlayerAPIService) GetInformationAboutTheUsersCurrentPlaybackExecute(r PlayerAPIGetInformationAboutTheUsersCurrentPlaybackRequest) (*CurrentlyPlayingContextObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrentlyPlayingContextObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.GetInformationAboutTheUsersCurrentPlayback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "form", "")
	}
	if r.additionalTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_types", r.additionalTypes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlayerAPIGetQueueRequest struct {
	ctx context.Context
	ApiService PlayerAPI
}

func (r PlayerAPIGetQueueRequest) Execute() (*QueueObject, *http.Response, error) {
	return r.ApiService.GetQueueExecute(r)
}

/*
GetQueue Get the User's Queue 

Get the list of objects that make up the user's queue.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIGetQueueRequest
*/
func (a *PlayerAPIService) GetQueue(ctx context.Context) PlayerAPIGetQueueRequest {
	return PlayerAPIGetQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueueObject
func (a *PlayerAPIService) GetQueueExecute(r PlayerAPIGetQueueRequest) (*QueueObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.GetQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/queue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlayerAPIGetRecentlyPlayedRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	limit *int32
	after *int32
	before *int32
}

func (r PlayerAPIGetRecentlyPlayedRequest) Limit(limit int32) PlayerAPIGetRecentlyPlayedRequest {
	r.limit = &limit
	return r
}

func (r PlayerAPIGetRecentlyPlayedRequest) After(after int32) PlayerAPIGetRecentlyPlayedRequest {
	r.after = &after
	return r
}

func (r PlayerAPIGetRecentlyPlayedRequest) Before(before int32) PlayerAPIGetRecentlyPlayedRequest {
	r.before = &before
	return r
}

func (r PlayerAPIGetRecentlyPlayedRequest) Execute() (*CursorPagingPlayHistoryObject, *http.Response, error) {
	return r.ApiService.GetRecentlyPlayedExecute(r)
}

/*
GetRecentlyPlayed Get Recently Played Tracks 

Get tracks from the current user's recently played tracks.
_**Note**: Currently doesn't support podcast episodes._


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIGetRecentlyPlayedRequest
*/
func (a *PlayerAPIService) GetRecentlyPlayed(ctx context.Context) PlayerAPIGetRecentlyPlayedRequest {
	return PlayerAPIGetRecentlyPlayedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CursorPagingPlayHistoryObject
func (a *PlayerAPIService) GetRecentlyPlayedExecute(r PlayerAPIGetRecentlyPlayedRequest) (*CursorPagingPlayHistoryObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CursorPagingPlayHistoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.GetRecentlyPlayed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/recently-played"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	market *string
	additionalTypes *string
}

func (r PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest) Market(market string) PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest {
	r.market = &market
	return r
}

func (r PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest) AdditionalTypes(additionalTypes string) PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest {
	r.additionalTypes = &additionalTypes
	return r
}

func (r PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest) Execute() (*CurrentlyPlayingContextObject, *http.Response, error) {
	return r.ApiService.GetTheUsersCurrentlyPlayingTrackExecute(r)
}

/*
GetTheUsersCurrentlyPlayingTrack Get Currently Playing Track 

Get the object currently being played on the user's Spotify account.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest
*/
func (a *PlayerAPIService) GetTheUsersCurrentlyPlayingTrack(ctx context.Context) PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest {
	return PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrentlyPlayingContextObject
func (a *PlayerAPIService) GetTheUsersCurrentlyPlayingTrackExecute(r PlayerAPIGetTheUsersCurrentlyPlayingTrackRequest) (*CurrentlyPlayingContextObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrentlyPlayingContextObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.GetTheUsersCurrentlyPlayingTrack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/currently-playing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "form", "")
	}
	if r.additionalTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_types", r.additionalTypes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlayerAPIPauseAUsersPlaybackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	deviceId *string
}

func (r PlayerAPIPauseAUsersPlaybackRequest) DeviceId(deviceId string) PlayerAPIPauseAUsersPlaybackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPIPauseAUsersPlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.PauseAUsersPlaybackExecute(r)
}

/*
PauseAUsersPlayback Pause Playback 

Pause playback on the user's account. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIPauseAUsersPlaybackRequest
*/
func (a *PlayerAPIService) PauseAUsersPlayback(ctx context.Context) PlayerAPIPauseAUsersPlaybackRequest {
	return PlayerAPIPauseAUsersPlaybackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) PauseAUsersPlaybackExecute(r PlayerAPIPauseAUsersPlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.PauseAUsersPlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/pause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	positionMs *int32
	deviceId *string
}

func (r PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest) PositionMs(positionMs int32) PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest {
	r.positionMs = &positionMs
	return r
}

func (r PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest) DeviceId(deviceId string) PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest) Execute() (*http.Response, error) {
	return r.ApiService.SeekToPositionInCurrentlyPlayingTrackExecute(r)
}

/*
SeekToPositionInCurrentlyPlayingTrack Seek To Position 

Seeks to the given position in the user’s currently playing track. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest
*/
func (a *PlayerAPIService) SeekToPositionInCurrentlyPlayingTrack(ctx context.Context) PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest {
	return PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) SeekToPositionInCurrentlyPlayingTrackExecute(r PlayerAPISeekToPositionInCurrentlyPlayingTrackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.SeekToPositionInCurrentlyPlayingTrack")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/seek"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.positionMs == nil {
		return nil, reportError("positionMs is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "position_ms", r.positionMs, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPISetRepeatModeOnUsersPlaybackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	state *string
	deviceId *string
}

func (r PlayerAPISetRepeatModeOnUsersPlaybackRequest) State(state string) PlayerAPISetRepeatModeOnUsersPlaybackRequest {
	r.state = &state
	return r
}

func (r PlayerAPISetRepeatModeOnUsersPlaybackRequest) DeviceId(deviceId string) PlayerAPISetRepeatModeOnUsersPlaybackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPISetRepeatModeOnUsersPlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetRepeatModeOnUsersPlaybackExecute(r)
}

/*
SetRepeatModeOnUsersPlayback Set Repeat Mode 

Set the repeat mode for the user's playback. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPISetRepeatModeOnUsersPlaybackRequest
*/
func (a *PlayerAPIService) SetRepeatModeOnUsersPlayback(ctx context.Context) PlayerAPISetRepeatModeOnUsersPlaybackRequest {
	return PlayerAPISetRepeatModeOnUsersPlaybackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) SetRepeatModeOnUsersPlaybackExecute(r PlayerAPISetRepeatModeOnUsersPlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.SetRepeatModeOnUsersPlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/repeat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPISetVolumeForUsersPlaybackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	volumePercent *int32
	deviceId *string
}

func (r PlayerAPISetVolumeForUsersPlaybackRequest) VolumePercent(volumePercent int32) PlayerAPISetVolumeForUsersPlaybackRequest {
	r.volumePercent = &volumePercent
	return r
}

func (r PlayerAPISetVolumeForUsersPlaybackRequest) DeviceId(deviceId string) PlayerAPISetVolumeForUsersPlaybackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPISetVolumeForUsersPlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetVolumeForUsersPlaybackExecute(r)
}

/*
SetVolumeForUsersPlayback Set Playback Volume 

Set the volume for the user’s current playback device. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPISetVolumeForUsersPlaybackRequest
*/
func (a *PlayerAPIService) SetVolumeForUsersPlayback(ctx context.Context) PlayerAPISetVolumeForUsersPlaybackRequest {
	return PlayerAPISetVolumeForUsersPlaybackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) SetVolumeForUsersPlaybackExecute(r PlayerAPISetVolumeForUsersPlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.SetVolumeForUsersPlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumePercent == nil {
		return nil, reportError("volumePercent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "volume_percent", r.volumePercent, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPISkipUsersPlaybackToNextTrackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	deviceId *string
}

func (r PlayerAPISkipUsersPlaybackToNextTrackRequest) DeviceId(deviceId string) PlayerAPISkipUsersPlaybackToNextTrackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPISkipUsersPlaybackToNextTrackRequest) Execute() (*http.Response, error) {
	return r.ApiService.SkipUsersPlaybackToNextTrackExecute(r)
}

/*
SkipUsersPlaybackToNextTrack Skip To Next 

Skips to next track in the user’s queue. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPISkipUsersPlaybackToNextTrackRequest
*/
func (a *PlayerAPIService) SkipUsersPlaybackToNextTrack(ctx context.Context) PlayerAPISkipUsersPlaybackToNextTrackRequest {
	return PlayerAPISkipUsersPlaybackToNextTrackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) SkipUsersPlaybackToNextTrackExecute(r PlayerAPISkipUsersPlaybackToNextTrackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.SkipUsersPlaybackToNextTrack")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/next"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPISkipUsersPlaybackToPreviousTrackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	deviceId *string
}

func (r PlayerAPISkipUsersPlaybackToPreviousTrackRequest) DeviceId(deviceId string) PlayerAPISkipUsersPlaybackToPreviousTrackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPISkipUsersPlaybackToPreviousTrackRequest) Execute() (*http.Response, error) {
	return r.ApiService.SkipUsersPlaybackToPreviousTrackExecute(r)
}

/*
SkipUsersPlaybackToPreviousTrack Skip To Previous 

Skips to previous track in the user’s queue. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPISkipUsersPlaybackToPreviousTrackRequest
*/
func (a *PlayerAPIService) SkipUsersPlaybackToPreviousTrack(ctx context.Context) PlayerAPISkipUsersPlaybackToPreviousTrackRequest {
	return PlayerAPISkipUsersPlaybackToPreviousTrackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) SkipUsersPlaybackToPreviousTrackExecute(r PlayerAPISkipUsersPlaybackToPreviousTrackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.SkipUsersPlaybackToPreviousTrack")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/previous"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPIStartAUsersPlaybackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	deviceId *string
	startAUsersPlaybackRequest *StartAUsersPlaybackRequest
}

func (r PlayerAPIStartAUsersPlaybackRequest) DeviceId(deviceId string) PlayerAPIStartAUsersPlaybackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPIStartAUsersPlaybackRequest) StartAUsersPlaybackRequest(startAUsersPlaybackRequest StartAUsersPlaybackRequest) PlayerAPIStartAUsersPlaybackRequest {
	r.startAUsersPlaybackRequest = &startAUsersPlaybackRequest
	return r
}

func (r PlayerAPIStartAUsersPlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartAUsersPlaybackExecute(r)
}

/*
StartAUsersPlayback Start/Resume Playback 

Start a new context or resume current playback on the user's active device. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIStartAUsersPlaybackRequest
*/
func (a *PlayerAPIService) StartAUsersPlayback(ctx context.Context) PlayerAPIStartAUsersPlaybackRequest {
	return PlayerAPIStartAUsersPlaybackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) StartAUsersPlaybackExecute(r PlayerAPIStartAUsersPlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.StartAUsersPlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/play"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startAUsersPlaybackRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPIToggleShuffleForUsersPlaybackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	state *bool
	deviceId *string
}

func (r PlayerAPIToggleShuffleForUsersPlaybackRequest) State(state bool) PlayerAPIToggleShuffleForUsersPlaybackRequest {
	r.state = &state
	return r
}

func (r PlayerAPIToggleShuffleForUsersPlaybackRequest) DeviceId(deviceId string) PlayerAPIToggleShuffleForUsersPlaybackRequest {
	r.deviceId = &deviceId
	return r
}

func (r PlayerAPIToggleShuffleForUsersPlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.ToggleShuffleForUsersPlaybackExecute(r)
}

/*
ToggleShuffleForUsersPlayback Toggle Playback Shuffle 

Toggle shuffle on or off for user’s playback. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPIToggleShuffleForUsersPlaybackRequest
*/
func (a *PlayerAPIService) ToggleShuffleForUsersPlayback(ctx context.Context) PlayerAPIToggleShuffleForUsersPlaybackRequest {
	return PlayerAPIToggleShuffleForUsersPlaybackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) ToggleShuffleForUsersPlaybackExecute(r PlayerAPIToggleShuffleForUsersPlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.ToggleShuffleForUsersPlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player/shuffle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlayerAPITransferAUsersPlaybackRequest struct {
	ctx context.Context
	ApiService PlayerAPI
	transferAUsersPlaybackRequest *TransferAUsersPlaybackRequest
}

func (r PlayerAPITransferAUsersPlaybackRequest) TransferAUsersPlaybackRequest(transferAUsersPlaybackRequest TransferAUsersPlaybackRequest) PlayerAPITransferAUsersPlaybackRequest {
	r.transferAUsersPlaybackRequest = &transferAUsersPlaybackRequest
	return r
}

func (r PlayerAPITransferAUsersPlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.TransferAUsersPlaybackExecute(r)
}

/*
TransferAUsersPlayback Transfer Playback 

Transfer playback to a new device and optionally begin playback. This API only works for users who have Spotify Premium. The order of execution is not guaranteed when you use this API with other Player API endpoints.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlayerAPITransferAUsersPlaybackRequest
*/
func (a *PlayerAPIService) TransferAUsersPlayback(ctx context.Context) PlayerAPITransferAUsersPlaybackRequest {
	return PlayerAPITransferAUsersPlaybackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlayerAPIService) TransferAUsersPlaybackExecute(r PlayerAPITransferAUsersPlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayerAPIService.TransferAUsersPlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/player"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferAUsersPlaybackRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
