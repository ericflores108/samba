/*
Spotify Web API

You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spotify

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AlbumsAPI interface {

	/*
	CheckUsersSavedAlbums Check User's Saved Albums 

	Check if one or more albums is already saved in the current Spotify user's 'Your Music' library.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AlbumsAPICheckUsersSavedAlbumsRequest
	*/
	CheckUsersSavedAlbums(ctx context.Context) AlbumsAPICheckUsersSavedAlbumsRequest

	// CheckUsersSavedAlbumsExecute executes the request
	//  @return []bool
	CheckUsersSavedAlbumsExecute(r AlbumsAPICheckUsersSavedAlbumsRequest) ([]bool, *http.Response, error)

	/*
	GetAnAlbum Get Album 

	Get Spotify catalog information for a single album.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return AlbumsAPIGetAnAlbumRequest
	*/
	GetAnAlbum(ctx context.Context, id string) AlbumsAPIGetAnAlbumRequest

	// GetAnAlbumExecute executes the request
	//  @return AlbumObject
	GetAnAlbumExecute(r AlbumsAPIGetAnAlbumRequest) (*AlbumObject, *http.Response, error)

	/*
	GetAnAlbumsTracks Get Album Tracks 

	Get Spotify catalog information about an album’s tracks.
Optional parameters can be used to limit the number of tracks returned.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return AlbumsAPIGetAnAlbumsTracksRequest
	*/
	GetAnAlbumsTracks(ctx context.Context, id string) AlbumsAPIGetAnAlbumsTracksRequest

	// GetAnAlbumsTracksExecute executes the request
	//  @return PagingSimplifiedTrackObject
	GetAnAlbumsTracksExecute(r AlbumsAPIGetAnAlbumsTracksRequest) (*PagingSimplifiedTrackObject, *http.Response, error)

	/*
	GetAnArtistsAlbums Get Artist's Albums 

	Get Spotify catalog information about an artist's albums.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return AlbumsAPIGetAnArtistsAlbumsRequest
	*/
	GetAnArtistsAlbums(ctx context.Context, id string) AlbumsAPIGetAnArtistsAlbumsRequest

	// GetAnArtistsAlbumsExecute executes the request
	//  @return PagingArtistDiscographyAlbumObject
	GetAnArtistsAlbumsExecute(r AlbumsAPIGetAnArtistsAlbumsRequest) (*PagingArtistDiscographyAlbumObject, *http.Response, error)

	/*
	GetMultipleAlbums Get Several Albums 

	Get Spotify catalog information for multiple albums identified by their Spotify IDs.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AlbumsAPIGetMultipleAlbumsRequest
	*/
	GetMultipleAlbums(ctx context.Context) AlbumsAPIGetMultipleAlbumsRequest

	// GetMultipleAlbumsExecute executes the request
	//  @return GetMultipleAlbums200Response
	GetMultipleAlbumsExecute(r AlbumsAPIGetMultipleAlbumsRequest) (*GetMultipleAlbums200Response, *http.Response, error)

	/*
	GetNewReleases Get New Releases 

	Get a list of new album releases featured in Spotify (shown, for example, on a Spotify player’s “Browse” tab).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AlbumsAPIGetNewReleasesRequest
	*/
	GetNewReleases(ctx context.Context) AlbumsAPIGetNewReleasesRequest

	// GetNewReleasesExecute executes the request
	//  @return GetNewReleases200Response
	GetNewReleasesExecute(r AlbumsAPIGetNewReleasesRequest) (*GetNewReleases200Response, *http.Response, error)

	/*
	GetUsersSavedAlbums Get User's Saved Albums 

	Get a list of the albums saved in the current Spotify user's 'Your Music' library.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AlbumsAPIGetUsersSavedAlbumsRequest
	*/
	GetUsersSavedAlbums(ctx context.Context) AlbumsAPIGetUsersSavedAlbumsRequest

	// GetUsersSavedAlbumsExecute executes the request
	//  @return PagingSavedAlbumObject
	GetUsersSavedAlbumsExecute(r AlbumsAPIGetUsersSavedAlbumsRequest) (*PagingSavedAlbumObject, *http.Response, error)

	/*
	RemoveAlbumsUser Remove Users' Saved Albums 

	Remove one or more albums from the current user's 'Your Music' library.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AlbumsAPIRemoveAlbumsUserRequest
	*/
	RemoveAlbumsUser(ctx context.Context) AlbumsAPIRemoveAlbumsUserRequest

	// RemoveAlbumsUserExecute executes the request
	RemoveAlbumsUserExecute(r AlbumsAPIRemoveAlbumsUserRequest) (*http.Response, error)

	/*
	SaveAlbumsUser Save Albums for Current User 

	Save one or more albums to the current user's 'Your Music' library.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AlbumsAPISaveAlbumsUserRequest
	*/
	SaveAlbumsUser(ctx context.Context) AlbumsAPISaveAlbumsUserRequest

	// SaveAlbumsUserExecute executes the request
	SaveAlbumsUserExecute(r AlbumsAPISaveAlbumsUserRequest) (*http.Response, error)
}

// AlbumsAPIService AlbumsAPI service
type AlbumsAPIService service

type AlbumsAPICheckUsersSavedAlbumsRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	ids *string
}

func (r AlbumsAPICheckUsersSavedAlbumsRequest) Ids(ids string) AlbumsAPICheckUsersSavedAlbumsRequest {
	r.ids = &ids
	return r
}

func (r AlbumsAPICheckUsersSavedAlbumsRequest) Execute() ([]bool, *http.Response, error) {
	return r.ApiService.CheckUsersSavedAlbumsExecute(r)
}

/*
CheckUsersSavedAlbums Check User's Saved Albums 

Check if one or more albums is already saved in the current Spotify user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AlbumsAPICheckUsersSavedAlbumsRequest
*/
func (a *AlbumsAPIService) CheckUsersSavedAlbums(ctx context.Context) AlbumsAPICheckUsersSavedAlbumsRequest {
	return AlbumsAPICheckUsersSavedAlbumsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []bool
func (a *AlbumsAPIService) CheckUsersSavedAlbumsExecute(r AlbumsAPICheckUsersSavedAlbumsRequest) ([]bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.CheckUsersSavedAlbums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums/contains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlbumsAPIGetAnAlbumRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	id string
	market *string
}

func (r AlbumsAPIGetAnAlbumRequest) Market(market string) AlbumsAPIGetAnAlbumRequest {
	r.market = &market
	return r
}

func (r AlbumsAPIGetAnAlbumRequest) Execute() (*AlbumObject, *http.Response, error) {
	return r.ApiService.GetAnAlbumExecute(r)
}

/*
GetAnAlbum Get Album 

Get Spotify catalog information for a single album.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return AlbumsAPIGetAnAlbumRequest
*/
func (a *AlbumsAPIService) GetAnAlbum(ctx context.Context, id string) AlbumsAPIGetAnAlbumRequest {
	return AlbumsAPIGetAnAlbumRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AlbumObject
func (a *AlbumsAPIService) GetAnAlbumExecute(r AlbumsAPIGetAnAlbumRequest) (*AlbumObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlbumObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.GetAnAlbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/albums/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlbumsAPIGetAnAlbumsTracksRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	id string
	market *string
	limit *int64
	offset *int64
}

func (r AlbumsAPIGetAnAlbumsTracksRequest) Market(market string) AlbumsAPIGetAnAlbumsTracksRequest {
	r.market = &market
	return r
}

func (r AlbumsAPIGetAnAlbumsTracksRequest) Limit(limit int64) AlbumsAPIGetAnAlbumsTracksRequest {
	r.limit = &limit
	return r
}

func (r AlbumsAPIGetAnAlbumsTracksRequest) Offset(offset int64) AlbumsAPIGetAnAlbumsTracksRequest {
	r.offset = &offset
	return r
}

func (r AlbumsAPIGetAnAlbumsTracksRequest) Execute() (*PagingSimplifiedTrackObject, *http.Response, error) {
	return r.ApiService.GetAnAlbumsTracksExecute(r)
}

/*
GetAnAlbumsTracks Get Album Tracks 

Get Spotify catalog information about an album’s tracks.
Optional parameters can be used to limit the number of tracks returned.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return AlbumsAPIGetAnAlbumsTracksRequest
*/
func (a *AlbumsAPIService) GetAnAlbumsTracks(ctx context.Context, id string) AlbumsAPIGetAnAlbumsTracksRequest {
	return AlbumsAPIGetAnAlbumsTracksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PagingSimplifiedTrackObject
func (a *AlbumsAPIService) GetAnAlbumsTracksExecute(r AlbumsAPIGetAnAlbumsTracksRequest) (*PagingSimplifiedTrackObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingSimplifiedTrackObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.GetAnAlbumsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/albums/{id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlbumsAPIGetAnArtistsAlbumsRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	id string
	includeGroups *string
	market *string
	limit *int64
	offset *int64
}

func (r AlbumsAPIGetAnArtistsAlbumsRequest) IncludeGroups(includeGroups string) AlbumsAPIGetAnArtistsAlbumsRequest {
	r.includeGroups = &includeGroups
	return r
}

func (r AlbumsAPIGetAnArtistsAlbumsRequest) Market(market string) AlbumsAPIGetAnArtistsAlbumsRequest {
	r.market = &market
	return r
}

func (r AlbumsAPIGetAnArtistsAlbumsRequest) Limit(limit int64) AlbumsAPIGetAnArtistsAlbumsRequest {
	r.limit = &limit
	return r
}

func (r AlbumsAPIGetAnArtistsAlbumsRequest) Offset(offset int64) AlbumsAPIGetAnArtistsAlbumsRequest {
	r.offset = &offset
	return r
}

func (r AlbumsAPIGetAnArtistsAlbumsRequest) Execute() (*PagingArtistDiscographyAlbumObject, *http.Response, error) {
	return r.ApiService.GetAnArtistsAlbumsExecute(r)
}

/*
GetAnArtistsAlbums Get Artist's Albums 

Get Spotify catalog information about an artist's albums.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return AlbumsAPIGetAnArtistsAlbumsRequest
*/
func (a *AlbumsAPIService) GetAnArtistsAlbums(ctx context.Context, id string) AlbumsAPIGetAnArtistsAlbumsRequest {
	return AlbumsAPIGetAnArtistsAlbumsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PagingArtistDiscographyAlbumObject
func (a *AlbumsAPIService) GetAnArtistsAlbumsExecute(r AlbumsAPIGetAnArtistsAlbumsRequest) (*PagingArtistDiscographyAlbumObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingArtistDiscographyAlbumObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.GetAnArtistsAlbums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists/{id}/albums"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_groups", r.includeGroups, "form", "")
	}
	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlbumsAPIGetMultipleAlbumsRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	ids *string
	market *string
}

func (r AlbumsAPIGetMultipleAlbumsRequest) Ids(ids string) AlbumsAPIGetMultipleAlbumsRequest {
	r.ids = &ids
	return r
}

func (r AlbumsAPIGetMultipleAlbumsRequest) Market(market string) AlbumsAPIGetMultipleAlbumsRequest {
	r.market = &market
	return r
}

func (r AlbumsAPIGetMultipleAlbumsRequest) Execute() (*GetMultipleAlbums200Response, *http.Response, error) {
	return r.ApiService.GetMultipleAlbumsExecute(r)
}

/*
GetMultipleAlbums Get Several Albums 

Get Spotify catalog information for multiple albums identified by their Spotify IDs.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AlbumsAPIGetMultipleAlbumsRequest
*/
func (a *AlbumsAPIService) GetMultipleAlbums(ctx context.Context) AlbumsAPIGetMultipleAlbumsRequest {
	return AlbumsAPIGetMultipleAlbumsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMultipleAlbums200Response
func (a *AlbumsAPIService) GetMultipleAlbumsExecute(r AlbumsAPIGetMultipleAlbumsRequest) (*GetMultipleAlbums200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMultipleAlbums200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.GetMultipleAlbums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/albums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlbumsAPIGetNewReleasesRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	limit *int64
	offset *int64
}

func (r AlbumsAPIGetNewReleasesRequest) Limit(limit int64) AlbumsAPIGetNewReleasesRequest {
	r.limit = &limit
	return r
}

func (r AlbumsAPIGetNewReleasesRequest) Offset(offset int64) AlbumsAPIGetNewReleasesRequest {
	r.offset = &offset
	return r
}

func (r AlbumsAPIGetNewReleasesRequest) Execute() (*GetNewReleases200Response, *http.Response, error) {
	return r.ApiService.GetNewReleasesExecute(r)
}

/*
GetNewReleases Get New Releases 

Get a list of new album releases featured in Spotify (shown, for example, on a Spotify player’s “Browse” tab).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AlbumsAPIGetNewReleasesRequest
*/
func (a *AlbumsAPIService) GetNewReleases(ctx context.Context) AlbumsAPIGetNewReleasesRequest {
	return AlbumsAPIGetNewReleasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetNewReleases200Response
func (a *AlbumsAPIService) GetNewReleasesExecute(r AlbumsAPIGetNewReleasesRequest) (*GetNewReleases200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNewReleases200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.GetNewReleases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/browse/new-releases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlbumsAPIGetUsersSavedAlbumsRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	limit *int64
	offset *int64
	market *string
}

func (r AlbumsAPIGetUsersSavedAlbumsRequest) Limit(limit int64) AlbumsAPIGetUsersSavedAlbumsRequest {
	r.limit = &limit
	return r
}

func (r AlbumsAPIGetUsersSavedAlbumsRequest) Offset(offset int64) AlbumsAPIGetUsersSavedAlbumsRequest {
	r.offset = &offset
	return r
}

func (r AlbumsAPIGetUsersSavedAlbumsRequest) Market(market string) AlbumsAPIGetUsersSavedAlbumsRequest {
	r.market = &market
	return r
}

func (r AlbumsAPIGetUsersSavedAlbumsRequest) Execute() (*PagingSavedAlbumObject, *http.Response, error) {
	return r.ApiService.GetUsersSavedAlbumsExecute(r)
}

/*
GetUsersSavedAlbums Get User's Saved Albums 

Get a list of the albums saved in the current Spotify user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AlbumsAPIGetUsersSavedAlbumsRequest
*/
func (a *AlbumsAPIService) GetUsersSavedAlbums(ctx context.Context) AlbumsAPIGetUsersSavedAlbumsRequest {
	return AlbumsAPIGetUsersSavedAlbumsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagingSavedAlbumObject
func (a *AlbumsAPIService) GetUsersSavedAlbumsExecute(r AlbumsAPIGetUsersSavedAlbumsRequest) (*PagingSavedAlbumObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingSavedAlbumObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.GetUsersSavedAlbums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlbumsAPIRemoveAlbumsUserRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	ids *string
	saveAlbumsUserRequest *SaveAlbumsUserRequest
}

func (r AlbumsAPIRemoveAlbumsUserRequest) Ids(ids string) AlbumsAPIRemoveAlbumsUserRequest {
	r.ids = &ids
	return r
}

func (r AlbumsAPIRemoveAlbumsUserRequest) SaveAlbumsUserRequest(saveAlbumsUserRequest SaveAlbumsUserRequest) AlbumsAPIRemoveAlbumsUserRequest {
	r.saveAlbumsUserRequest = &saveAlbumsUserRequest
	return r
}

func (r AlbumsAPIRemoveAlbumsUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveAlbumsUserExecute(r)
}

/*
RemoveAlbumsUser Remove Users' Saved Albums 

Remove one or more albums from the current user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AlbumsAPIRemoveAlbumsUserRequest
*/
func (a *AlbumsAPIService) RemoveAlbumsUser(ctx context.Context) AlbumsAPIRemoveAlbumsUserRequest {
	return AlbumsAPIRemoveAlbumsUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AlbumsAPIService) RemoveAlbumsUserExecute(r AlbumsAPIRemoveAlbumsUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.RemoveAlbumsUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saveAlbumsUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlbumsAPISaveAlbumsUserRequest struct {
	ctx context.Context
	ApiService AlbumsAPI
	ids *string
	saveAlbumsUserRequest *SaveAlbumsUserRequest
}

func (r AlbumsAPISaveAlbumsUserRequest) Ids(ids string) AlbumsAPISaveAlbumsUserRequest {
	r.ids = &ids
	return r
}

func (r AlbumsAPISaveAlbumsUserRequest) SaveAlbumsUserRequest(saveAlbumsUserRequest SaveAlbumsUserRequest) AlbumsAPISaveAlbumsUserRequest {
	r.saveAlbumsUserRequest = &saveAlbumsUserRequest
	return r
}

func (r AlbumsAPISaveAlbumsUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.SaveAlbumsUserExecute(r)
}

/*
SaveAlbumsUser Save Albums for Current User 

Save one or more albums to the current user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AlbumsAPISaveAlbumsUserRequest
*/
func (a *AlbumsAPIService) SaveAlbumsUser(ctx context.Context) AlbumsAPISaveAlbumsUserRequest {
	return AlbumsAPISaveAlbumsUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AlbumsAPIService) SaveAlbumsUserExecute(r AlbumsAPISaveAlbumsUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsAPIService.SaveAlbumsUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saveAlbumsUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
